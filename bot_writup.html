<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-26 Fri 19:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Machine Learn You Some Dota2</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Aren R. Windham" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Machine Learn You Some Dota2</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb5c1dfb">Introduction</a></li>
<li><a href="#org0c1597a">Distributed Dota as a service</a>
<ul>
<li><a href="#orgf2dc006">Parsing Game Logs</a></li>
<li><a href="#orgad2579c">AWK</a></li>
<li><a href="#orgd5d694e">Distributed Dota</a></li>
<li><a href="#org2097420">Coroutines Are Cool</a>
<ul>
<li><a href="#org4953625">Server</a></li>
<li><a href="#orgd889996">Worker</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c76e07">Machine Learning</a>
<ul>
<li><a href="#orgc2b4899">Genetic Algorithms</a></li>
</ul>
</li>
<li><a href="#org274e7ae">Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb5c1dfb" class="outline-2">
<h2 id="orgb5c1dfb">Introduction</h2>
<div class="outline-text-2" id="text-orgb5c1dfb">
<p>
The problem is this; We have a Dota2 bot that is becoming
increasingly hard to program. Our bot is built with a heuristics
based <a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>. Each state has a hard coded weight that will
give precedence to an action that can be taken that moment. Dota is
an incredibly complex game and it is nearly impossible to tell if a
change to a weight is beneficial or if the bot just got lucky one
game. We need a way to run hundreds of games and get hard data on if
the change was beneficial.
</p>
</div>
</div>
<div id="outline-container-org0c1597a" class="outline-2">
<h2 id="org0c1597a">Distributed Dota as a service</h2>
<div class="outline-text-2" id="text-org0c1597a">
<p>
We need to run a Dota executable multiple times with different bot
files to determine which set of weights were the most effective in
practice. Docker is the obvious choice. Docker lets us
automatically load the game, bot files, and return the
output. Setting up a docker container that grabs the Dota and bot
files from the local disk is simple. After some googling and
testing we have a way to run a game of Dota and pipe the output to
a file.
</p>
<pre class="example">
FROM fedora:latest
COPY . /scripts
VOLUME /dota
CMD sh /scripts/run_game.sh
</pre>
</div>
<div id="outline-container-orgf2dc006" class="outline-3">
<h3 id="orgf2dc006">Parsing Game Logs</h3>
<div class="outline-text-3" id="text-orgf2dc006">
<p>
Of course Dota couldn't provide nice json files as logs so let's get
to parsing. Dota game logs vary in length but are consistent with
spacing and formatting. For example, if a tower dies the log will
always read: <code>Building: npc_dota_3_tower destroyed</code>. Man if only there
were a way to use regular expressions to match lines and grab fields
from those lines.
</p>
</div>
</div>
<div id="outline-container-orgad2579c" class="outline-3">
<h3 id="orgad2579c">AWK</h3>
<div class="outline-text-3" id="text-orgad2579c">
<p>
Awk is a specific purpose programming language (like wolfram alpha or
bison) as opposed to a general purpose programming language (like Lisp
or Prolog). This means that awk does one thing, and one thing well;
text stream processing. Using Gnu Awk we can easily write statement that
will write the time a tower dies.
Using this as the basis, it is a non issue to implement every other
action that can happen throughout the game.
</p>

<div class="org-src-container">
<pre class="src src-awk"><span style="color: #a020f0;">if</span>($0 ~ <span style="color: #8b2252;">/Building: npc_dota_.*_(tower|rax)/</span>){
    <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"tower %s died at %d"</span>, $2, <span style="color: #483d8b;">systime</span>()
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5d694e" class="outline-3">
<h3 id="orgd5d694e">Distributed Dota</h3>
<div class="outline-text-3" id="text-orgd5d694e">
<p>
We can run multiple games and pipe the nicely formatted output to
files. Now we would like to run hundreds of games and use the data
from them to create pretty graphs representing how well our bot
does. each docker container runs one game of Dota, uses two cores, and
about 1.3 gigs of ram. Since our computers have 8 threads and 8 gigs
of ram we can optimally run 4 games at a time. What we would like to
do is tell the server to run 100 games and have each computer run up
to 4 games in parallel until that 100 game quota is met.
</p>
</div>
</div>
<div id="outline-container-org2097420" class="outline-3">
<h3 id="org2097420">Coroutines Are Cool</h3>
<div class="outline-text-3" id="text-org2097420">
<p>
We will build our own custom solution in a programming language made
for distributed computing. Our general layout will work like this.
</p>
</div>
<div id="outline-container-org4953625" class="outline-4">
<h4 id="org4953625">Server</h4>
<div class="outline-text-4" id="text-org4953625">
<p>
The server is informed that 100 games are to be played. The server
then starts each worker and opens a http server to listen for requests
from each worker. It listens for a START request and replies yes or no
depending on if there are still games to be run or not. If it receives
a json file instead of a start request it will log it and continue on.
The server is just smart enough to worry about how many games it is
running and how many games it needs to run, nothing else. Load
balancing is handled by the worker.
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b22222;">// </span><span style="color: #b22222;">start http server</span>
finished.<span style="color: #0000ff;">Add</span>(1)
<span style="color: #a020f0;">go</span> <span style="color: #0000ff;">httpListener</span>()

<span style="color: #b22222;">// </span><span style="color: #b22222;">spin up workers</span>
<span style="color: #a020f0;">for</span> i, worker := <span style="color: #a020f0;">range</span>(workers) {
        fmt.<span style="color: #0000ff;">Printf</span>(<span style="color: #8b2252;">"Starting worker %s\n"</span>, worker)
        err := <span style="color: #0000ff;">startWorker</span>(worker)
        <span style="color: #a020f0;">if</span> err != <span style="color: #008b8b;">nil</span> {
                log.<span style="color: #0000ff;">Print</span>(err)
        }
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wait for every worker to complete their games</span>
finished.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
finished is a wait group meaning that finished.Wait() will block until
every worker has sent back it's json data.
</p>
</div>
</div>
<div id="outline-container-orgd889996" class="outline-4">
<h4 id="orgd889996">Worker</h4>
<div class="outline-text-4" id="text-orgd889996">
<p>
The worker is in charge of load balancing it's computer and running
games.  When the server is woke it sends <code>MAX_GAMES</code> requests to the
server, asking to start games. In Go this is easy
</p>
<div class="org-src-container">
<pre class="src src-go">limit := limiter.<span style="color: #0000ff;">NewConcurrencyLimiter</span>(MAX_GAMES)
done := <span style="color: #008b8b;">false</span>
<span style="color: #a020f0;">for</span> !done {
        done = limit.<span style="color: #0000ff;">Execute</span>(RunGame)
        time.<span style="color: #0000ff;">Sleep</span>(time.Second * 3) <span style="color: #b22222;">// </span><span style="color: #b22222;">because other computers are slow</span>
}
limit.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
<code>RunGame</code> sends a http request to the server and runs a game based on
the response. since running a docker container/Dota game, blocks until
it has finished running we need to spawn a new process every time we
start a game. Again, in Go this is easy.
</p>

<p>
Now that we have our server and workers communicating nicely we can
run lots of games and generate huge amounts of data.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org4c76e07" class="outline-2">
<h2 id="org4c76e07">Machine Learning</h2>
<div class="outline-text-2" id="text-org4c76e07">
<p>
As fun as tweaking random bot variables is, it's not very
efficient.. for humans. Luckily computers can do boring tasks very
fast. Since we have a lack of time and processing power we will use an
algorithm that takes less of both.
</p>
</div>
<div id="outline-container-orgc2b4899" class="outline-3">
<h3 id="orgc2b4899">Genetic Algorithms</h3>
<div class="outline-text-3" id="text-orgc2b4899">
<p>
Genetic algorithms are a type of machine learning based on random
mutations and survival of the fittest. Instead of running the server
once and getting a result back, we want that resul to be fed back into
next round's bots. The new server will work as follows:
</p>


<div class="figure">
<p><img src="genetic_algo.png" alt="genetic_algo.png" />
</p>
</div>

<p>
In the sake of clarity i'm not explaining the nitty gritty of how
genes are selected but if you want to learn more about genetic
algorithms wikipedia has a good list <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">here</a>. Genetic algorithms are just
a small taste of machine learning and are still incredibly complicated.
</p>

<p>
Implementing a genetic algorithm is only as hard as running the
server over and over and processing data. In order to process each
games data we need to write a function that will go over the logs and
generate a fitness score for each hero. A fitness score is a
cumulative score of how well the bot did with the new mutaed
genes. An example fitness function would look something like this:
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #a020f0;">func</span> <span style="color: #0000ff;">CalculateFitness</span>(hero *<span style="color: #228b22;">heroEvaluation</span>) <span style="color: #228b22;">float64</span> {
        fitness := 0.0

        fitness += hero.winrate * WIN_MOD
        fitness += hero.killsPerMinute * KPM_MOD
        fitness += hero.assistsPerMinute * APM_MOD
        fitness += hero.goldPerMinute * GPM_MOD
        fitness += hero.deathsPerMinute * DPM_MOD
        fitness += hero.experiencePerMinute * XPM_MOD

        <span style="color: #a020f0;">return</span> fitness
}
</pre>
</div>
<p>
Each score would then be added together and given a percentage to be
incorperated into the gene pool. 
</p>
<div class="org-src-container">
<pre class="src src-go">chance := (totalFitness / heroFitness)
</pre>
</div>
<p>
And voila, you taught a computer to reproduce. Go have some cake, you
deserve it bud.
</p>
</div>
</div>
</div>
<div id="outline-container-org274e7ae" class="outline-2">
<h2 id="org274e7ae">Conclusion</h2>
<div class="outline-text-2" id="text-org274e7ae">
<p>
Writing a Dota bot is not fun. Designing and implementing a
distributed, machine learning powered dota swarm is. The complexity
and variance in each little problem means that we were able to help
each other solve things we may not have learned in a one dimensional
project. From docker, to machine learning, to shell scripting and
network administration. I learned a lot about programming and, more
importantly, project design and problem solving.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Aren R. Windham</p>
<p class="date">Created: 2019-04-26 Fri 19:51</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
