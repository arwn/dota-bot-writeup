<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-26 Fri 18:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="aren windham" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga274225">1. Introduction</a></li>
<li><a href="#orgce56bd5">2. Distributed Dota as a service</a>
<ul>
<li><a href="#org5e336a8">2.1. docker as a function</a></li>
<li><a href="#orgadda4c5">2.2. parsing game logs</a>
<ul>
<li><a href="#org9124c3c">2.2.1. awk</a></li>
</ul>
</li>
<li><a href="#org5fb59b3">2.3. distributed Dota</a>
<ul>
<li><a href="#org8e0536f">2.3.1. coroutines are cool</a></li>
</ul>
</li>
<li><a href="#orgf8dd1d5">2.4. machine learning</a>
<ul>
<li><a href="#orgac20efd">2.4.1. genetic algorithms</a></li>
<li><a href="#org73b9cc0">2.4.2. awk</a></li>
</ul>
</li>
<li><a href="#org91b1a7b">2.5. distributed Dota</a>
<ul>
<li><a href="#org8158600">2.5.1. coroutines are cool</a></li>
</ul>
</li>
<li><a href="#org40ea826">2.6. machine learning</a>
<ul>
<li><a href="#org50880a1">2.6.1. genetic algorithms</a></li>
<li><a href="#org5635628">2.6.2. awk</a></li>
</ul>
</li>
<li><a href="#orgebce42b">2.7. distributed Dota</a>
<ul>
<li><a href="#org53bc948">2.7.1. coroutines are cool</a></li>
</ul>
</li>
<li><a href="#orgd5986a5">2.8. machine learning</a>
<ul>
<li><a href="#org61456e6">2.8.1. genetic algorithms</a></li>
<li><a href="#orgdb88a86">2.8.2. awk</a></li>
</ul>
</li>
<li><a href="#org4ea44c6">2.9. distributed Dota</a>
<ul>
<li><a href="#org61bb59b">2.9.1. coroutines are cool</a></li>
</ul>
</li>
<li><a href="#orgc58f871">2.10. machine learning</a>
<ul>
<li><a href="#org0d0e8ad">2.10.1. genetic algorithms</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Machine learn some Dota.
</p>
<div id="outline-container-orga274225" class="outline-2">
<h2 id="orga274225"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Creating a custom machine learning solution. The obvious step after
writing a custom Dota bot is to teach it to teach itself.
</p>
</div>
</div>
<div id="outline-container-orgce56bd5" class="outline-2">
<h2 id="orgce56bd5"><span class="section-number-2">2</span> Distributed Dota as a service</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org5e336a8" class="outline-3">
<h3 id="org5e336a8"><span class="section-number-3">2.1</span> docker as a function</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We needed to run a Dota executable multiple times with different bot
files to determine which set of weights were the most effective in
practice. Docker was the obvious choice. Setting up a docker container
that grabs the Dota and bot files from the local disk was
simple. After some googling and testing we had a way to run a game of
Dota and pipe the output to a file.
</p>
<pre class="example">
FROM fedora:latest
COPY . /scripts
VOLUME /dota
CMD sh /scripts/run_game.sh
</pre>
</div>
</div>
<div id="outline-container-orgadda4c5" class="outline-3">
<h3 id="orgadda4c5"><span class="section-number-3">2.2</span> parsing game logs</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Of course Dota couldn't provide nice json files as logs so let's get
to parsing. Dota game logs vary in length but are consistent with
spacing and formatting. For example, if a tower dies the log will
always read: <code>Building: npc_dota_3_tower destroyed</code>. Man if only there
were a way to use regular expressions to match lines and grab fields
from those lines.
</p>
</div>
<div id="outline-container-org9124c3c" class="outline-4">
<h4 id="org9124c3c"><span class="section-number-4">2.2.1</span> awk</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
AWK is a specific purpose programming language (like wolfram alpha or
bison) as opposed to a general purpose programming language (like Lisp
or Prolog). This means that AWK does one thing, and one thing well;
text stream processing. Using Gnu awk we can easily write statement that
will write the time a tower dies.
</p>
<div class="org-src-container">
<pre class="src src-awk"><span style="color: #a020f0;">if</span>($0 ~ <span style="color: #8b2252;">/Building: npc_dota_.*_(tower|rax)/</span>){
    <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"tower %s died at %d"</span>, $2, <span style="color: #483d8b;">systime</span>()
}
</pre>
</div>
<p>
Using this as the basis, it is a non issue to implement every other
action that can happen throughout the game.
</p>
</div>
</div>
</div>
<div id="outline-container-org5fb59b3" class="outline-3">
<h3 id="org5fb59b3"><span class="section-number-3">2.3</span> distributed Dota</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can run multiple games and pipe the nicely formatted output to
files. Now we would like to run hundreds of games and use the data
from them to create pretty graphs representing how well our bot
does. each docker container runs one game of Dota, uses two cores, and
about 1.3 gigs of ram. Since our computers have 8 threads and 8 gigs
of ram we can optimally run 4 games at a time. What we would like to
do is tell the server to run 100 games and have each computer run up
to 4 games in parallel until that 100 game quota is met.
</p>
</div>
<div id="outline-container-org8e0536f" class="outline-4">
<h4 id="org8e0536f"><span class="section-number-4">2.3.1</span> coroutines are cool</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
We will build our own custom solution in a programming language made
for distributed computing. Our general layout will work like this.
</p>
</div>
<ol class="org-ol">
<li><a id="org6a0ef17"></a>server<br />
<div class="outline-text-5" id="text-2-3-1-1">
<p>
The server is informed that 100 games are to be played. The server
then starts each worker and opens a http server to listen for requests
from each worker. It listens for a START request and replies yes or no
depending on if there are still games to be run or not. If it receives
a json file instead of a start request it will log it and continue on.
The server is just smart enough to worry about how many games it is
running and how many games it needs to run, nothing else. Load
balancing is handled by the worker.
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b22222;">// </span><span style="color: #b22222;">start http server</span>
finished.<span style="color: #0000ff;">Add</span>(1)
<span style="color: #a020f0;">go</span> <span style="color: #0000ff;">httpListener</span>()

<span style="color: #b22222;">// </span><span style="color: #b22222;">spin up workers</span>
<span style="color: #a020f0;">for</span> i, worker := <span style="color: #a020f0;">range</span>(workers) {
        fmt.<span style="color: #0000ff;">Printf</span>(<span style="color: #8b2252;">"Starting worker %s\n"</span>, worker)
        err := <span style="color: #0000ff;">startWorker</span>(worker)
        <span style="color: #a020f0;">if</span> err != <span style="color: #008b8b;">nil</span> {
                log.<span style="color: #0000ff;">Print</span>(err)
        }
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wait for every worker to complete their games</span>
finished.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
finished is a wait group meaning that finished.Wait() will block until
every worker has sent back it's json data.
</p>
</div>
</li>
<li><a id="org25f8c29"></a>worker<br />
<div class="outline-text-5" id="text-2-3-1-2">
<p>
The worker is in charge of load balancing it's computer and running
games.  When the server is woke it sends MAX<sub>GAMES</sub> requests to the
server asking to start games. In Go this is easy
</p>
<div class="org-src-container">
<pre class="src src-go">limit := limiter.<span style="color: #0000ff;">NewConcurrencyLimiter</span>(MAX_GAMES)
done := <span style="color: #008b8b;">false</span>
<span style="color: #a020f0;">for</span> !done {
        done = limit.<span style="color: #0000ff;">Execute</span>(runGame)
        time.<span style="color: #0000ff;">Sleep</span>(time.Second * 3) <span style="color: #b22222;">// </span><span style="color: #b22222;">because other computers are slow</span>
}
limit.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
runGame sends a http request to the server and runs a game based on
the response. since running a docker container/Dota game, blocks until
it has finished running we need to spawn a new process every time we
start a game. Again, in Go this is easy.
</p>

<p>
Now that we have our server and workers communicating nicely we can
run lots of games and generate huge amounts of data.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgf8dd1d5" class="outline-3">
<h3 id="orgf8dd1d5"><span class="section-number-3">2.4</span> machine learning</h3>
<div class="outline-text-3" id="text-2-4">
<p>
As fun as tweaking random bot variables is, it's not very
efficient.. for humans. Luckily computers can do boring tasks very
fast. Since we have a lack of time and processing power we will use an
algorithm that takes less of both.
</p>
</div>
<div id="outline-container-orgac20efd" class="outline-4">
<h4 id="orgac20efd"><span class="section-number-4">2.4.1</span> genetic algorithms</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Genetic algorithms are a type of machine learning based on random
mutations and survival of the fittest. Instead of running the server
once and getting a result back, we want that resul to be fed back into
next round's bots. The new server will work as follows:
</p>
</div>
</div>
<div id="outline-container-org73b9cc0" class="outline-4">
<h4 id="org73b9cc0"><span class="section-number-4">2.4.2</span> awk</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
AWK is a specific purpose programming language (like wolfram alpha or
bison) as opposed to a general purpose programming language (like Lisp
or Prolog). This means that AWK does one thing, and one thing well;
text stream processing. Using Gnu awk we can easily write statement that
will write the time a tower dies.
</p>
<div class="org-src-container">
<pre class="src src-awk"><span style="color: #a020f0;">if</span>($0 ~ <span style="color: #8b2252;">/Building: npc_dota_.*_(tower|rax)/</span>){
    <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"tower %s died at %d"</span>, $2, <span style="color: #483d8b;">systime</span>()
}
</pre>
</div>
<p>
Using this as the basis, it is a non issue to implement every other
action that can happen throughout the game.
</p>
</div>
</div>
</div>
<div id="outline-container-org91b1a7b" class="outline-3">
<h3 id="org91b1a7b"><span class="section-number-3">2.5</span> distributed Dota</h3>
<div class="outline-text-3" id="text-2-5">
<p>
We can run multiple games and pipe the nicely formatted output to
files. Now we would like to run hundreds of games and use the data
from them to create pretty graphs representing how well our bot
does. each docker container runs one game of Dota, uses two cores, and
about 1.3 gigs of ram. Since our computers have 8 threads and 8 gigs
of ram we can optimally run 4 games at a time. What we would like to
do is tell the server to run 100 games and have each computer run up
to 4 games in parallel until that 100 game quota is met.
</p>
</div>
<div id="outline-container-org8158600" class="outline-4">
<h4 id="org8158600"><span class="section-number-4">2.5.1</span> coroutines are cool</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
We will build our own custom solution in a programming language made
for distributed computing. Our general layout will work like this.
</p>
</div>
<ol class="org-ol">
<li><a id="orgebeb4eb"></a>server<br />
<div class="outline-text-5" id="text-2-5-1-1">
<p>
The server is informed that 100 games are to be played. The server
then starts each worker and opens a http server to listen for requests
from each worker. It listens for a START request and replies yes or no
depending on if there are still games to be run or not. If it receives
a json file instead of a start request it will log it and continue on.
The server is just smart enough to worry about how many games it is
running and how many games it needs to run, nothing else. Load
balancing is handled by the worker.
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b22222;">// </span><span style="color: #b22222;">start http server</span>
finished.<span style="color: #0000ff;">Add</span>(1)
<span style="color: #a020f0;">go</span> <span style="color: #0000ff;">httpListener</span>()

<span style="color: #b22222;">// </span><span style="color: #b22222;">spin up workers</span>
<span style="color: #a020f0;">for</span> i, worker := <span style="color: #a020f0;">range</span>(workers) {
        fmt.<span style="color: #0000ff;">Printf</span>(<span style="color: #8b2252;">"Starting worker %s\n"</span>, worker)
        err := <span style="color: #0000ff;">startWorker</span>(worker)
        <span style="color: #a020f0;">if</span> err != <span style="color: #008b8b;">nil</span> {
                log.<span style="color: #0000ff;">Print</span>(err)
        }
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wait for every worker to complete their games</span>
finished.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
finished is a wait group meaning that finished.Wait() will block until
every worker has sent back it's json data.
</p>
</div>
</li>
<li><a id="org15cff6e"></a>worker<br />
<div class="outline-text-5" id="text-2-5-1-2">
<p>
The worker is in charge of load balancing it's computer and running
games.  When the server is woke it sends MAX<sub>GAMES</sub> requests to the
server asking to start games. In Go this is easy
</p>
<div class="org-src-container">
<pre class="src src-go">limit := limiter.<span style="color: #0000ff;">NewConcurrencyLimiter</span>(MAX_GAMES)
done := <span style="color: #008b8b;">false</span>
<span style="color: #a020f0;">for</span> !done {
        done = limit.<span style="color: #0000ff;">Execute</span>(runGame)
        time.<span style="color: #0000ff;">Sleep</span>(time.Second * 3) <span style="color: #b22222;">// </span><span style="color: #b22222;">because other computers are slow</span>
}
limit.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
runGame sends a http request to the server and runs a game based on
the response. since running a docker container/Dota game, blocks until
it has finished running we need to spawn a new process every time we
start a game. Again, in Go this is easy.
</p>

<p>
Now that we have our server and workers communicating nicely we can
run lots of games and generate huge amounts of data.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org40ea826" class="outline-3">
<h3 id="org40ea826"><span class="section-number-3">2.6</span> machine learning</h3>
<div class="outline-text-3" id="text-2-6">
<p>
As fun as tweaking random bot variables is, it's not very
efficient.. for humans. Luckily computers can do boring tasks very
fast. Since we have a lack of time and processing power we will use an
algorithm that takes less of both.
</p>
</div>
<div id="outline-container-org50880a1" class="outline-4">
<h4 id="org50880a1"><span class="section-number-4">2.6.1</span> genetic algorithms</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Genetic algorithms are a type of machine learning based on random
mutations and survival of the fittest. Instead of running the server
once and getting a result back, we want that resul to be fed back into
next round's bots. The new server will work as follows:
</p>
</div>
</div>
<div id="outline-container-org5635628" class="outline-4">
<h4 id="org5635628"><span class="section-number-4">2.6.2</span> awk</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
AWK is a specific purpose programming language (like wolfram alpha or
bison) as opposed to a general purpose programming language (like Lisp
or Prolog). This means that AWK does one thing, and one thing well;
text stream processing. Using Gnu awk we can easily write statement that
will write the time a tower dies.
</p>
<div class="org-src-container">
<pre class="src src-awk"><span style="color: #a020f0;">if</span>($0 ~ <span style="color: #8b2252;">/Building: npc_dota_.*_(tower|rax)/</span>){
    <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"tower %s died at %d"</span>, $2, <span style="color: #483d8b;">systime</span>()
}
</pre>
</div>
<p>
Using this as the basis, it is a non issue to implement every other
action that can happen throughout the game.
</p>
</div>
</div>
</div>
<div id="outline-container-orgebce42b" class="outline-3">
<h3 id="orgebce42b"><span class="section-number-3">2.7</span> distributed Dota</h3>
<div class="outline-text-3" id="text-2-7">
<p>
We can run multiple games and pipe the nicely formatted output to
files. Now we would like to run hundreds of games and use the data
from them to create pretty graphs representing how well our bot
does. each docker container runs one game of Dota, uses two cores, and
about 1.3 gigs of ram. Since our computers have 8 threads and 8 gigs
of ram we can optimally run 4 games at a time. What we would like to
do is tell the server to run 100 games and have each computer run up
to 4 games in parallel until that 100 game quota is met.
</p>
</div>
<div id="outline-container-org53bc948" class="outline-4">
<h4 id="org53bc948"><span class="section-number-4">2.7.1</span> coroutines are cool</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
We will build our own custom solution in a programming language made
for distributed computing. Our general layout will work like this.
</p>
</div>
<ol class="org-ol">
<li><a id="orgf251c2c"></a>server<br />
<div class="outline-text-5" id="text-2-7-1-1">
<p>
The server is informed that 100 games are to be played. The server
then starts each worker and opens a http server to listen for requests
from each worker. It listens for a START request and replies yes or no
depending on if there are still games to be run or not. If it receives
a json file instead of a start request it will log it and continue on.
The server is just smart enough to worry about how many games it is
running and how many games it needs to run, nothing else. Load
balancing is handled by the worker.
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b22222;">// </span><span style="color: #b22222;">start http server</span>
finished.<span style="color: #0000ff;">Add</span>(1)
<span style="color: #a020f0;">go</span> <span style="color: #0000ff;">httpListener</span>()

<span style="color: #b22222;">// </span><span style="color: #b22222;">spin up workers</span>
<span style="color: #a020f0;">for</span> i, worker := <span style="color: #a020f0;">range</span>(workers) {
        fmt.<span style="color: #0000ff;">Printf</span>(<span style="color: #8b2252;">"Starting worker %s\n"</span>, worker)
        err := <span style="color: #0000ff;">startWorker</span>(worker)
        <span style="color: #a020f0;">if</span> err != <span style="color: #008b8b;">nil</span> {
                log.<span style="color: #0000ff;">Print</span>(err)
        }
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wait for every worker to complete their games</span>
finished.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
finished is a wait group meaning that finished.Wait() will block until
every worker has sent back it's json data.
</p>
</div>
</li>
<li><a id="org4baad2d"></a>worker<br />
<div class="outline-text-5" id="text-2-7-1-2">
<p>
The worker is in charge of load balancing it's computer and running
games.  When the server is woke it sends MAX<sub>GAMES</sub> requests to the
server asking to start games. In Go this is easy
</p>
<div class="org-src-container">
<pre class="src src-go">limit := limiter.<span style="color: #0000ff;">NewConcurrencyLimiter</span>(MAX_GAMES)
done := <span style="color: #008b8b;">false</span>
<span style="color: #a020f0;">for</span> !done {
        done = limit.<span style="color: #0000ff;">Execute</span>(runGame)
        time.<span style="color: #0000ff;">Sleep</span>(time.Second * 3) <span style="color: #b22222;">// </span><span style="color: #b22222;">because other computers are slow</span>
}
limit.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
runGame sends a http request to the server and runs a game based on
the response. since running a docker container/Dota game, blocks until
it has finished running we need to spawn a new process every time we
start a game. Again, in Go this is easy.
</p>

<p>
Now that we have our server and workers communicating nicely we can
run lots of games and generate huge amounts of data.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgd5986a5" class="outline-3">
<h3 id="orgd5986a5"><span class="section-number-3">2.8</span> machine learning</h3>
<div class="outline-text-3" id="text-2-8">
<p>
As fun as tweaking random bot variables is, it's not very
efficient.. for humans. Luckily computers can do boring tasks very
fast. Since we have a lack of time and processing power we will use an
algorithm that takes less of both.
</p>
</div>
<div id="outline-container-org61456e6" class="outline-4">
<h4 id="org61456e6"><span class="section-number-4">2.8.1</span> genetic algorithms</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
Genetic algorithms are a type of machine learning based on random
mutations and survival of the fittest. Instead of running the server
once and getting a result back, we want that resul to be fed back into
next round's bots. The new server will work as follows:
</p>
</div>
</div>
<div id="outline-container-orgdb88a86" class="outline-4">
<h4 id="orgdb88a86"><span class="section-number-4">2.8.2</span> awk</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
AWK is a specific purpose programming language (like wolfram alpha or
bison) as opposed to a general purpose programming language (like Lisp
or Prolog). This means that AWK does one thing, and one thing well;
text stream processing. Using Gnu awk we can easily write statement that
will write the time a tower dies.
</p>
<div class="org-src-container">
<pre class="src src-awk"><span style="color: #a020f0;">if</span>($0 ~ <span style="color: #8b2252;">/Building: npc_dota_.*_(tower|rax)/</span>){
    <span style="color: #483d8b;">printf</span> <span style="color: #8b2252;">"tower %s died at %d"</span>, $2, <span style="color: #483d8b;">systime</span>()
}
</pre>
</div>
<p>
Using this as the basis, it is a non issue to implement every other
action that can happen throughout the game.
</p>
</div>
</div>
</div>
<div id="outline-container-org4ea44c6" class="outline-3">
<h3 id="org4ea44c6"><span class="section-number-3">2.9</span> distributed Dota</h3>
<div class="outline-text-3" id="text-2-9">
<p>
We can run multiple games and pipe the nicely formatted output to
files. Now we would like to run hundreds of games and use the data
from them to create pretty graphs representing how well our bot
does. each docker container runs one game of Dota, uses two cores, and
about 1.3 gigs of ram. Since our computers have 8 threads and 8 gigs
of ram we can optimally run 4 games at a time. What we would like to
do is tell the server to run 100 games and have each computer run up
to 4 games in parallel until that 100 game quota is met.
</p>
</div>
<div id="outline-container-org61bb59b" class="outline-4">
<h4 id="org61bb59b"><span class="section-number-4">2.9.1</span> coroutines are cool</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
We will build our own custom solution in a programming language made
for distributed computing. Our general layout will work like this.
</p>
</div>
<ol class="org-ol">
<li><a id="orgfe76af5"></a>server<br />
<div class="outline-text-5" id="text-2-9-1-1">
<p>
The server is informed that 100 games are to be played. The server
then starts each worker and opens a http server to listen for requests
from each worker. It listens for a START request and replies yes or no
depending on if there are still games to be run or not. If it receives
a json file instead of a start request it will log it and continue on.
The server is just smart enough to worry about how many games it is
running and how many games it needs to run, nothing else. Load
balancing is handled by the worker.
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #b22222;">// </span><span style="color: #b22222;">start http server</span>
finished.<span style="color: #0000ff;">Add</span>(1)
<span style="color: #a020f0;">go</span> <span style="color: #0000ff;">httpListener</span>()

<span style="color: #b22222;">// </span><span style="color: #b22222;">spin up workers</span>
<span style="color: #a020f0;">for</span> i, worker := <span style="color: #a020f0;">range</span>(workers) {
        fmt.<span style="color: #0000ff;">Printf</span>(<span style="color: #8b2252;">"Starting worker %s\n"</span>, worker)
        err := <span style="color: #0000ff;">startWorker</span>(worker)
        <span style="color: #a020f0;">if</span> err != <span style="color: #008b8b;">nil</span> {
                log.<span style="color: #0000ff;">Print</span>(err)
        }
}
<span style="color: #b22222;">// </span><span style="color: #b22222;">wait for every worker to complete their games</span>
finished.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
finished is a wait group meaning that finished.Wait() will block until
every worker has sent back it's json data.
</p>
</div>
</li>
<li><a id="org871c46b"></a>worker<br />
<div class="outline-text-5" id="text-2-9-1-2">
<p>
The worker is in charge of load balancing it's computer and running
games.  When the server is woke it sends MAX<sub>GAMES</sub> requests to the
server asking to start games. In Go this is easy
</p>
<div class="org-src-container">
<pre class="src src-go">limit := limiter.<span style="color: #0000ff;">NewConcurrencyLimiter</span>(MAX_GAMES)
done := <span style="color: #008b8b;">false</span>
<span style="color: #a020f0;">for</span> !done {
        done = limit.<span style="color: #0000ff;">Execute</span>(runGame)
        time.<span style="color: #0000ff;">Sleep</span>(time.Second * 3) <span style="color: #b22222;">// </span><span style="color: #b22222;">because other computers are slow</span>
}
limit.<span style="color: #0000ff;">Wait</span>()
</pre>
</div>
<p>
runGame sends a http request to the server and runs a game based on
the response. since running a docker container/Dota game, blocks until
it has finished running we need to spawn a new process every time we
start a game. Again, in Go this is easy.
</p>

<p>
Now that we have our server and workers communicating nicely we can
run lots of games and generate huge amounts of data.
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgc58f871" class="outline-3">
<h3 id="orgc58f871"><span class="section-number-3">2.10</span> machine learning</h3>
<div class="outline-text-3" id="text-2-10">
<p>
As fun as tweaking random bot variables is, it's not very
efficient.. for humans. Luckily computers can do boring tasks very
fast. Since we have a lack of time and processing power we will use an
algorithm that takes less of both.
</p>
</div>
<div id="outline-container-org0d0e8ad" class="outline-4">
<h4 id="org0d0e8ad"><span class="section-number-4">2.10.1</span> genetic algorithms</h4>
<div class="outline-text-4" id="text-2-10-1">
<p>
Genetic algorithms are a type of machine learning based on random
mutations and survival of the fittest. Instead of running the server
once and getting a result back, we want that resul to be fed back into
next round's bots. The new server will work as follows:
</p>

<div class="figure">
<p><img src="genetic_algo.png" alt="genetic_algo.png" />
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: aren windham</p>
<p class="date">Created: 2019-04-26 Fri 18:10</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
